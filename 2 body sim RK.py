# -*- coding: utf-8 -*-
"""
Created on Mon Jul 20 10:44:03 2015

@author: eryn
"""

# -*- coding: utf-8 -*-
"""
N body simulator

Author: Eryn Cangi
For CIERA REU summer 2015

2-body simulation, using Newtonian mechanics. Allows creation of multiple body 
objects, which are Turtle types. Body class has a method to calculate forces
from all other bodies in the system.

Heavily lifted from http://fiftyexamples.readthedocs.org/en/latest/gravity.html
License is MIT license, free to use and modify as desired for any use.
"""

import turtle as t
import numpy as np
#from math import sin, cos, atan2
from scipy.integrate import ode
    
class Body(t.Turtle):
    '''
    Defines a body object and its attributes, i.e. a planet, satellite, etc.
    Inherits from Turtle for drawing purposes.
    '''

    def __init__(self, name, mass, color, pos, vel):
        t.Turtle.__init__(self)
        self.name = name
        self.mass = mass
        self.pen(pencolor=color)
        self.location = pos                         # numpy array            
        self.velocity = vel                         #

    def __repr__(self):
        return '{name} at {pos} with speed {vel}, mass {mass}'\
        .format(name = self.name, pos = self.location, vel = self.velocity, 
                mass = self.mass)
        
    def grav(self, other):
        '''
        Accepts as input another Body object and returns the value -GM/r^3 
        which is needed for the differential equation
        '''
        
        G = 6.67384 * 10**(-11)

        if self is other:
            raise ValueError("Can't attract self. This error should have been" 
                                "handled elsewhere...")

        # Calculate distance between objects
        dr = self.location - other.location         # format [dx, dy]
        r = np.linalg.norm(dr) 
        
        # -GM/r^3
        GMr3 = -(G * other.mass) / (r**3)
        
        return GMr3
        
        
def info(step, bodies, AU):
    '''
    Currently prints information to the console.
    Possibly may adapt later to fill arrays with data generated by simulation
    '''
    
    print('Step #{}'.format(step))
    for body in bodies:
        s = '{:<8}  Pos. x ={:>6.2f} y ={:>6.2f} | Vel. x ={:>10.3f} y ={:>10.3f}'.format(
            body.name, body.location[0]/AU, body.location[1]/AU, \
            body.velocity[0], body.velocity[1])
        print(s)
    print()
    return


def run(bodies, SCALE, AU):
    '''
    Runs the main simulation. Accepts as input the SCALE and AU variables, as
    they are needed here as well.
    
        Feed in the expression for dv/dt into the ode function. 

    Receive a solution. This is v. 

    Feed solution into ode again. 

    Receive solution. This is r. 

    Use solution to update position of planet. 
    '''
    
    timestep = 24*3600                 # Step = 1 day; in seconds
    t0 = 0
    dt = 0.1
    
    step = 1
    
    while True:
        info(step, bodies, AU)
        step += 1
        
        # Get the GMr3 between a body and another. Currently only works for 2.
        for body in bodies:
            for other in bodies:
                if body is other:               # ignore force by body on self
                    continue
                GMr3 = body.grav(other)
                # get right side of diffeqs: GMr3 * r_x, GMr3 * r_y
                right_side = GMr3 * np.array([body.position[0], body.position[1]])
                
                # Actual diffeq evaluation
                v = ode(right_side).set_integrator('dopri5')

                # Set initial values, time step we care about and integrate for v.
                r0 = body.position              # pass in body's current position
                v.set_initial_value(r0, t0)                       
                v.integrate(v.t + dt)
                velocity = v.y
                
                # take results of integration to v and feed into integration for r
                r = ode(velocity).set_integrator('dopri5')
                # what are the initial conditions for this? (y0)
                r.set_initial_value(y0, t0)
                r.integrate(r.t + dt)
                new_pos = r.y
                
            # next spot for turtle to move to
            next_position = new_pos * SCALE

            if body.name == 'Sun':
                body.hideturtle()
                body.penup()
                body.goto(next_position)
                body.dot(50)
            elif body.name == 'Earth' or 'Mars':
                body.shape('circle')
                if step==2:                      # move to start w/o a line drawn
                    body.penup()
                    body.goto(next_position)
                    body.pendown()
                else:
                    body.goto(next_position)
                    
        t0 += 0.1
        if step == 5000:
            break


def main():
    '''
    Main loop which sets the parameters and calls the simulation
    '''  
    
    # Set the mood
    t.bgcolor('black')
    
    # Assumed scale: 100 pixels = 1AU.
    AU = 149.6e9                # 149.6 billion meters is one astronomical unit
    SCALE = 250 / AU                            # 2e-9;  100 px
    
    # Declare initial positions and velocities for two bodies
    sun_loc = np.array([0,0])
    sun_vel = np.array([0,0])
    
    earth_loc = np.array([-1*AU, 0])
    earth_vel = np.array([0, 35000])              # shows elliptical
    
    #mars_loc = np.array([(-227.9e9/146.6e9)*AU,0])
    #mars_vel = np.array([0,24070])
    
    sun = Body('Sun', 2e30, 'yellow', sun_loc, sun_vel)
    earth = Body('Earth', 5.9742e24, 'blue', earth_loc, earth_vel)
    #mars = Body('Mars', 6.39e23, 'red', mars_loc, mars_vel)
    
    run([sun, earth], SCALE, AU)
    
if __name__ == '__main__':
    main()