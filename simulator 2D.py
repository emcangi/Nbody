# -*- coding: utf-8 -*-
"""
N body simulator

Author: Eryn Cangi
For CIERA REU summer 2015

Heavily lifted from http://fiftyexamples.readthedocs.org/en/latest/gravity.html
License is MIT license, free to use and modify as desired for any use.

This one works in 2D, for preliminary testing purposes.
"""

import turtle as t
import numpy as np
from math import sin, cos, atan2
#import pdb
    
class Body(t.Turtle):
    '''
    Defines a body object and its attributes, i.e. a planet, satellite, etc.
    Inherits from Turtle for easy drawing
    '''

    def __init__(self, name, mass, color, pos, vel):
        t.Turtle.__init__(self)
        self.name = name
        self.mass = mass
        self.pen(pencolor=color)
        self.location = pos                         # numpy array            
        self.velocity = vel                         #

    def __repr__(self):
        return '{name} at {pos} with speed {vel}, mass {mass}'\
        .format(name = self.name, pos = self.location, vel = self.velocity, 
                mass = self.mass)
        
    def force(self, other):
        '''
        Calculates force between the object and another one
        '''
        
        G = 6.67384 * 10**(-11)

        if self is other:
            raise ValueError("Can't attract object to itself")

        # calculate distance
        # can possibly improve per: http://bit.ly/1I6rLjj
        dr = self.location - other.location         # format [dx, dy]
        r = np.linalg.norm(dr) 
        
        # calculate force
        fg = -(G * self.mass * other.mass) / (r**2)
        
        # calculate direction of force, polar coordinates; use of atan2 
        # guarantees integrity of directionality 
        theta = atan2(dr[1], dr[0])
        
        # calculate force components, which will be returned
        gravity = np.array([fg * cos(theta), fg * sin(theta)])
        
        return gravity
        
        
def info(step, bodies, AU):
    '''
    Currently prints information to the console.
    Possibly may adapt later to fill arrays with data generated by simulation
    '''
    
    print('Step #{}'.format(step))
    for body in bodies:
        s = '{:<8}  Pos. x ={:>6.2f} y ={:>6.2f} | Vel. x ={:>10.3f} y ={:>10.3f}'.format(
            body.name, body.location[0]/AU, body.location[1]/AU, \
            body.velocity[0], body.velocity[1])
        print(s)
    print()


def run(bodies, SCALE, AU):
    '''
    Runs the main simulation
    '''
    
    timestep = 24*3600                  # start with one day as the time step
    
    #for body in bodies:
        #body.penup()
        #body.hideturtle()
      
    step = 1
    while True:
        info(step, bodies, AU)
        step += 1

        force = {}                     # dictionary of forces from other bodies
        
        # Add up all of the forces exerted on 'body'.
        for body in bodies:
            total_fx = total_fy = 0.0
            for other in bodies:
                if body is other:               # ignore force by body on self
                    continue
                grav_vector = body.force(other)  # angle is angle of force
                total_fx += grav_vector[0]
                total_fy += grav_vector[1]
        
            # Record the total force exerted in a dictionary
            force[body] = (total_fx, total_fy)
        
        # Update velocities based on force; vel = accel * time, pos = vel*time
        for body in bodies:
            
            # obscure the turtles
            body.hideturtle()
            
            fx, fy = force[body]
            body.velocity += (np.array([fx, fy]) / body.mass) * timestep
            body.location += body.velocity * timestep
            
            # next spot for turtle to move to
            next_position = body.location * SCALE

            if body.name == 'Sun':
                body.penup()
                body.goto(next_position)
                body.dot(50)
            elif body.name == 'Earth':
                body.shape('circle')
                body.showturtle()
                if step==2:                      # move to start w/o a line drawn
                    body.penup()
                    body.goto(next_position)
                    body.pendown()
                else:
                    body.goto(next_position)
        
        if step == 1000:
            break


def main():
    '''
    Main loop which sets the parameters and calls the simulation
    '''  
    
    # Set the mood
    bgcolor('black')
    
    # Assumed scale: 100 pixels = 1AU.
    AU = 149.6e9     # 149.6 billion meters is one astronomical unit
    SCALE = 250 / AU                            # 2e-9; 
    
    # Declare positions and velocities for two bodies
    sun_pos = np.array([0,0])
    sun_vel = [0,0]
    earth_pos = np.array([-1*AU, 0])
    earth_vel = np.array([0, 3e4])              # earth = 30 km per sec
    
    sun = Body('Sun', 2e30, 'yellow', sun_pos, sun_vel)
    earth = Body('Earth', 5.9742e24, 'blue', earth_pos, earth_vel)

    run([sun, earth], SCALE, AU)
    
    
if __name__ == '__main__':
    main()
